#Reading 7, Team C
* [Automatic repair of buggy if conditions and missing preconditions with SMT](http://dl.acm.org/citation.cfm?id=2593740)

1. *Reading*
  + 	 Favio DeMarco, Jifeng Xuan, Daniel Le Berre, Martin Monperrus. 2014 Automatic repair of buggy if conditions and missing preconditions with SMT. CSTVA 2014 Proceedings of the 6th International Workshop on Constraints in Software Testing, Verification, and Analysis.

2. *Keywords*
  1. **Automatic repair**: The automatic repair of bugs like buggy IF conditions using a given approach.
  2. **Buggy if condition**: Conditional statements that have some kind of bug that cause the program execution to lead to a different branch in the execution path, leading to unexpected behavior. NOPOL aims to fix these bugs automatically.
  3. **Missing precondition**: A common bug relating to branching. Preconditions distinguish different values of variables and when they are missing it can lead to bugs like null pointer exceptions. NOPOL aims to fix these bugs automatically.
  4. **SMT**: Satisfiability Modulo Theory. An SMT solver detects if there is a solution, if one exists the solution is translated back into source code by a generator.
  5. **Angelic fix localization**: An algorithm that identifies repair locations and repair oracles. It is a technique of modifying the program state to find angelic pairs.

3. *Notes (4 of 19)*
  1. **Motivational statements**: The authors list the motivation of automatic software repair as decreasing the cost of fixing bugs. The automatically-produced patches can be used by developers as potential solutions or even put in as is if time is of the essence. Giving developers a potential solution should ease the time needed for the developers to understand the bug and design a fix for it.
  2. **Study Instruments**: NOPOL used several case studies as study instruments that other systems in the past have used as well as future systems can use to compare results to NOPOL and others. The first case study was a classical program, Tcas, that was used as an example by the related work SemFix. Tcas is a collision avoidance system in the Software-artifact Infrastructure Repository (SIR) and is made up of 125 lines of code. The patch created by NOPOL differs from the patch made by SemFix but both pass all test cases and are an acceptable fix. The second case study was the Commons-Math library in Apache. Commons-Math is a lightweight library for common math/stats problems and is made up of 5000 lines of code with 353 test cases. This was a real-world use case as the bug NOPOL found and fixed was an actual bug in the library. The last case study was the missing precondition example created by the authors to show how NOPOL can fix missing preconditions. In order to fix an ArrayIndexOutOfBounds exception preconditions had to be generated by NOPOL and this SMT solution is converted as the final patch to fix the bug.
  3. **Related work**: GenProg is a test-suite based program repair approach that uses genetic programming by viewing a program as an AST and generating another AST patch to provide multiple candidate patches and use the candidate that passes all test cases. GenProg has an average success rate of 77 percent. SemFix is a program repair approach that uses semantic analysis. Unlike GenProg, SemFix generates patches by combining symbolic execution, constraint solving, and program synthesis. SemFix has a higher accuracy rate and executes in less time than GenProg. NOPOL can repair missing parameters which SemFix cannot. Related to the use of SMT solvers, Jha et al. mined program oracles based on examples and used SMT solvers to create constraints. This addressed the same problem as NOPOLby encoding the synthesis constraint with a first-order logic formula.
  4. **Future work**: The authors plan to evaluate their approach on more real-world bugs. NOPOL will be extended to fix bugs in conditionals for loop structures like while and for loops.

4. *Needs improvement*
  1. NOPOL can only handle a single point of failure, meaning programs with only one fault. The authors state that NOPOL cannot "stack patches" as the search space would be "exponentially larger", but they did not mention a fix for this. Could NOPOL be run sequentially over some code with multiple bugs, fixing one at a time? Real-world code doesn't just have a single bug everytime so if NOPOL is to have any real-world use it needs to address this limitation. The authors reference other previous works as having the same issue but it is a big enough issue to address and fix. 
  2. Since the paper only used NOPOL on 3 case studies that fit their requirements, the reader is not told the actual success rate and performance of NOPOL. The only mentioned execution time is that the Apache Common Maths bug took a "few seconds to fix" while more detailed stats were only presented for related works (like GenProgs average success rate of 77%). Benchmarks (accuracy, time, etc) would be useful for measuring NOPOL.
  3. Since NOPOL is comprised of multiple systems like GZoltar for fault localization and CVC4 as a SMT solver it would have been useful to see some type of system architecture described in a visualization to help get the big picture of what NOPOL is doing while producing patches for the case study faults.

5. *Connection to other papers*
  1. **Connection to GZoltar**: This paper uses GZoltar's library for fault localization. NOPOL calls GZoltar to order the repair locations generated and then generates SMTLIB files to pass to a SMT solver CVC4.

